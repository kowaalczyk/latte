use std::str::FromStr;

use crate::parser::ast;
use crate::parser::ast::Keyed;
use crate::util::env;
use crate::util::env::UniqueLocEnv;
use crate::location::Located;
use crate::error::FrontendError;


use lalrpop_util::ErrorRecovery;
grammar<'err>(errors: &'err mut Vec<FrontendError<usize>>);

// --- macros ---

/// vector of 0 or more T separated by Sep
Separated<Sep, T>: Vec<T> = {
    <v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

/// vector of 1 or more T separated by Sep
NonEmptySeparated<Sep, T>: Vec<T> = {
    <v:(<T> Sep)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

/// wraps T in the Located struct, storing beginning and the end of the span
ToLocated<T>: Located<T, usize> = {
    <begin:@L> <item:T> => Located::new(item, begin)
};

// --- top level ---

pub Program: ast::Program = {
    <topdefs:LocTopDef+> => {
        let mut functions = env::LocEnv::new();
        let mut classes = env::LocEnv::new();
        for topdef in topdefs {
            let location = topdef.get_location();
            match topdef.item {
                ast::TopDef::Class { cls } => {
                    let mut loc_cls = Located::new(cls.clone(), location);
                    classes.insert_unique(cls.get_key().clone(), loc_cls)
                        .or_else(|e| { errors.push(e); Err(()) });
                },
                ast::TopDef::Function { func } => {
                    let mut loc_func = Located::new(func.clone(), location);
                    functions.insert_unique(func.get_key().clone(), loc_func)
                        .or_else(|e| { errors.push(e); Err(()) });
                },
                ast::TopDef::Error => (),
            };
        }
        ast::Program { functions, classes }
    },
};

LocTopDef = ToLocated<TopDef>;
TopDef: ast::TopDef = {
    <ret:Type> <ident:Ident> "(" <arg_vec:LocArgs> ")" <block:LocBlock> => {
        match ast::Function::new(ret, ident, arg_vec, block) {
            Ok(func) => ast::TopDef::Function { func },
            Err(e) => {
                errors.push(e);
                ast::TopDef::Error
            }
        }
    },
    "class" <ident:Ident> "{" <var_vec:LocClassVar*> <method_vec:LocMethod*> "}" => {
        let mut method_env_errors: Vec<FrontendError<usize>> = method_vec.iter()
            .filter(|m| m.item.is_err())
            .map(|e| e.item.clone().unwrap_err())
            .collect();
        if method_env_errors.is_empty() {
            let method_vec = method_vec.iter()
                .map(|m| Located::new(m.item.clone().unwrap(), m.get_location()))
                .collect();
            match ast::Class::new(ident, var_vec, method_vec) {
                Ok(cls) => ast::TopDef::Class { cls },
                Err(e) => {
                    errors.push(e);
                    ast::TopDef::Error
                }
            }
        } else {
            errors.append(&mut method_env_errors);
            ast::TopDef::Error
        }
    },
    "class" <ident:Ident> "extends" <parent:Ident> "{" <var_vec:LocClassVar*> <method_vec:LocMethod*> "}" => {
        let mut method_env_errors: Vec<FrontendError<usize>> = method_vec.iter()
            .filter(|m| m.item.is_err())
            .map(|e| e.item.clone().unwrap_err())
            .collect();
        if method_env_errors.is_empty() {
            let method_vec = method_vec.iter()
                .map(|m| Located::new(m.item.clone().unwrap(), m.get_location()))
                .collect();
            match ast::Class::new(ident, var_vec, method_vec) {
                Ok(mut cls) => ast::TopDef::Class { cls: cls.with_parent(&parent) },
                Err(e) => {
                    errors.push(e);
                    ast::TopDef::Error
                }
            }
        } else {
            errors.append(&mut method_env_errors);
            ast::TopDef::Error
        }
    },
    ! => {
        errors.push(FrontendError::from(<>));
        ast::TopDef::Error
    },
};

LocClassVar = ToLocated<ClassVar>;
ClassVar: ast::ClassVar = {
    <t:Type> <ident:Ident> ";" => {
        ast::ClassVar { t, ident, default: Option::None }
    },
    <t:Type> <ident:Ident> "=" <default:LocExpr0> ";" => {
        ast::ClassVar { t, ident, default: Option::Some(default) }
    },
};

LocMethod = ToLocated<Method>;
Method: Result<ast::Function, FrontendError<usize>> = {
    <ret:Type> <ident:Ident> "(" <args:LocArgs> ")" <block:LocBlock> => {
        // not to be confused with ast::TopDef::Function 
        ast::Function::new(ret, ident, args, block)
    },
};

LocArg = ToLocated<Arg>;
Arg: ast::Arg = {
    <t:Type> <ident:Ident> => ast::Arg { t, ident },
};

LocArgs = Separated<",", LocArg>;


// --- blocks ---

LocBlock = ToLocated<Block>;
Block: ast::Block = {
    "{" <stmts:LocStatement*> "}" => ast::Block { stmts },
};

// --- statements ---

LocStatement = ToLocated<Statement>;
Statement = StatementAllowDanglingIf<"I">;

LocStatementADI<I> = ToLocated<StatementAllowDanglingIf<I>>;
StatementAllowDanglingIf<I>: Box<ast::Statement> = {
    <block:LocBlock> => {
        Box::new(ast::Statement::Block { block })
    },
    ";" => Box::new(ast::Statement::Empty),
    <t:Type> <items:DeclItems> ";" => {
        Box::new(ast::Statement::Decl { t, items })
    },
    <r:LocRef> "=" <expr:LocExpr0> ";" => {
        Box::new(ast::Statement::Ass { r, expr })
    },
    <r:LocRef> "++" ";" => {
        Box::new(ast::Statement::Mut { r, op: ast::StatementOp::Increment })
    },
    <r:LocRef> "--" ";" => {
        Box::new(ast::Statement::Mut { r, op: ast::StatementOp::Decrement })
    },
    "return" <e:LocExpr0> ";" => {
        Box::new(ast::Statement::Return { expr: Option::Some(e) })
    },
    "return" ";" => {
        Box::new(ast::Statement::Return { expr: Option::None })
    },
    // we only allow dangling if when template parameter I != "" (I == "I")
    "if" "(" <expr:LocExpr0> ")" <stmt:LocStatementADI<"I">> if I != "" => {
        Box::new(ast::Statement::Cond { expr, stmt })
    },
    "if" "(" <expr:LocExpr0> ")" <stmt_true:LocStatementADI<"">> "else" <stmt_false:LocStatementADI<I>> => {
        Box::new(ast::Statement::CondElse { expr, stmt_true, stmt_false })
    },
    "while" "(" <expr:LocExpr0> ")" <stmt:LocStatementADI<I>> => {
        Box::new(ast::Statement::While { expr, stmt })
    },
    "for" "(" <t:Type> <ident:Ident> ":" <arr:LocExpr0> ")" <stmt:LocStatementADI<I>> => {
        Box::new(ast::Statement::For { t, ident, arr, stmt })
    },
    <expr:LocExpr0> ";" => Box::new(ast::Statement::Expr { expr }),
    ! => {
        errors.push(FrontendError::from(<>));
        Box::new(ast::Statement::Error)
    },
};

DeclItem: ast::DeclItem = {
    <ident:Ident> => ast::DeclItem::NoInit { ident },
    <ident:Ident> "=" <val:LocExpr0> => ast::DeclItem::Init { ident, val },
};

DeclItems = NonEmptySeparated<",", DeclItem>;

// --- types ---

Type: ast::Type = {
    "int" => ast::Type::Int,
    "string" => ast::Type::Str,
    "boolean" => ast::Type::Bool,
    "void" => ast::Type::Void,
    <ident:Ident> => ast::Type::Class { ident },
    <t:Type> "[]" => ast::Type::Array { item_t: Box::new(t) },
};

Types = Separated<",", Type>;

// --- expressions ---

LocExpr0 = ToLocated<Expr0>;
Expr0: Box<ast::Expression> = {
    <l:LocExpr1> "||" <r:LocExpr0> => {
        Box::new(ast::Expression::Binary { left: l, op: ast::BinaryOperator::Or, right: r })
    },
    <e:Expr1> => (<>),
};

LocExpr1 = ToLocated<Expr1>;
Expr1: Box<ast::Expression> = {
    <l:LocExpr2> "&&" <r:LocExpr1> => {
        Box::new(ast::Expression::Binary { left: l, op: ast::BinaryOperator::And, right: r })
    },
    <e:Expr2> => (<>),
};

LocExpr2 = ToLocated<Expr2>;
Expr2: Box<ast::Expression> = {
    <left:LocExpr2> <op:RelOp> <right:LocExpr3> => {
        Box::new(ast::Expression::Binary { left, op, right })
    },
    <e:Expr3> => (<>),
};

RelOp: ast::BinaryOperator = {
    "<" => ast::BinaryOperator::Less,
    "<=" => ast::BinaryOperator::Less,
    "==" => ast::BinaryOperator::Equal,
    "!=" => ast::BinaryOperator::NotEqual,
    ">=" => ast::BinaryOperator::GreaterEqual,
    ">" => ast::BinaryOperator::Greater,
};

LocExpr3 = ToLocated<Expr3>;
Expr3: Box<ast::Expression> = {
    <l:LocExpr3> <op:AddOp> <r:LocExpr4> => {
        Box::new(ast::Expression::Binary { left: l, op: op, right: r })
    },
    <e:Expr4> => (<>),
};

AddOp: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Plus,
    "-" => ast::BinaryOperator::Minus,
};

LocExpr4 = ToLocated<Expr4>;
Expr4: Box<ast::Expression> = {
    <l:LocExpr4> <op:MulOp> <r:LocExpr5> => {
        Box::new(ast::Expression::Binary { left: l, op: op, right: r })
    },
    <e:Expr5> => (<>),
};

MulOp: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::Times,
    "/" => ast::BinaryOperator::Divide,
    "%" => ast::BinaryOperator::Modulo,
};

LocExpr5 = ToLocated<Expr5>;
Expr5: Box<ast::Expression> = {
    "-" <e:LocExpr6> => Box::new(ast::Expression::Unary { op: ast::UnaryOperator::Neg, arg: e }),
    "!" <e:LocExpr6> => Box::new(ast::Expression::Unary { op: ast::UnaryOperator::Not, arg: e }),
    <e:Expr6> => (<>),
};

LocExpr6 = ToLocated<Expr6>;
Expr6: Box<ast::Expression> = {
    "new" <t:Type> => {
        Box::new(ast::Expression::InitDefault { t })
    },
    "new" <item_t:Type> "[" <size:LocExpr0> "]" => {
        Box::new(ast::Expression::InitArr { 
            t: ast::Type::Array { item_t: Box::new(item_t) }, 
            size 
        })
    },
    <r:LocRef> "(" <args:Exprs> ")" => {
        Box::new(ast::Expression::App { r, args })
    },
    <r:LocRef> => {
        Box::new(ast::Expression::Reference { r })
    },
    <val:Num> => Box::new(ast::Expression::LitInt { val }),
    "true" => Box::new(ast::Expression::LitBool { val: true }),
    "false" => Box::new(ast::Expression::LitBool { val: false }),
    "null" => Box::new(ast::Expression::LitNull),
    // TODO: Unescape characters from the string (!!!)
    r#""[^"]*""# => Box::new(ast::Expression::LitStr { val: String::from(<>) }),
    // nested expression conflicts with type cast, so we only implement the possibility of casting null
    "(" <t:Type> <expr:LocNullCast> => Box::new(ast::Expression::Cast { t, expr }),
    // https://stackoverflow.com/questions/27448189/bison-reduce-reduce-conflict-with-casting-and-expression-parentheses
    // "(" <t:Type> ")" <expr:Expr6> => Box::new(ast::Expression::Cast { t, expr }),
    "(" <e:Expr0> ")" => (<>),
};

Exprs = Separated<",", LocExpr0>;

// --- special null cast ---

LocNullCast = ToLocated<NullCast>;
NullCast: Box<ast::Expression> = {
    ")null" => Box::new(ast::Expression::LitNull),
};

// --- literals ---

Ident: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => String::from(<>),
};

LocRef = ToLocated<Reference>;
Reference: ast::Reference = {
    <ident:Ident> => ast::Reference::Ident { ident },
    <obj:Ident> "." <field:Ident> => ast::Reference::Object { obj, field },
    <arr:Ident> "[" <idx:LocExpr0> "]" => ast::Reference::Array { arr, idx },
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),  // no negative numbers, just as the LBNF Integer
};
